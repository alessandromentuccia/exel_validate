import argparse
import itertools
import json
import logging
import random
import re
import time
from collections import OrderedDict
from functools import reduce
from pathlib import Path
from typing import Dict, List

#import openpyxl 
import pandas as pd
import numpy as np
import requests
#import xlrd
#import xlsxwriter
#from openpyxl.utils import get_column_letter

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)
f_handler = logging.FileHandler('generator.log', 'a+', 'utf-8')
c_handler = logging.StreamHandler()
formatter = logging.Formatter(
    '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
f_handler.setFormatter(formatter)
c_handler.setFormatter(formatter)
logger.addHandler(f_handler)
logger.addHandler(c_handler)

EXAMPLE_FILE_PATH = 'generated_examples.md'

class PhraseTemplate(object):
    def __init__(self, original_line: str, string_to_fill: str, slot_list: List[List[str]]):
        self.original_line = original_line
        self.string_to_fill = string_to_fill
        self.slot_list = slot_list


class knowledge_action():

    file_name = ""
    file_data = {}

    def import_k(self):
        logging.warning("import CSV")

        template_file = input("Enter your template file.xlsx: ") 
        print(template_file) 
        template_file = Path(template_file)
        self.file_name = template_file
        if template_file.is_file(): #C:\Users\aless\csi-progetti\FaqBot\faqbot-09112020.xlsx
            df = pd.read_excel(template_file, 'FAQ_templates', converters={'question_number': str}).replace(np.nan, '', regex=True)
            #print ("print JSON")
            #print(sh)
            data_list = {'question_number': {}}
            
            for index, row in df.iterrows():
                data = OrderedDict()
                if row["question_number"] not in data_list["question_number"]:
                    data[row[1]] = [row["question_template"]]
                    self.file_data.update({ row["question_number"]: [row["question_type"], row["question_number"], row["question_template"], row["answer"], row["note"]]})
                    data_list["question_number"].update(data)
                    print("data_list: %s", data_list)
                else: 
                    data_list["question_number"][row["question_number"]].append(row["question_template"])
                    self.file_data.update({ row["question_number"]: [row["question_type"], row["question_number"], row["question_template"], row["answer"], row["note"]]})

            #with open("RulesJson.json", "w", encoding="utf-8") as writeJsonfile:
            #    json.dump(data_list, writeJsonfile, indent=4,default=str) 
            logging.warning("initiate generation")
            self.extract_template(data_list)
        else:
            print("Il file non esiste, prova a ricaricare il file con la directory corretta.\n")

    def extract_template(self, template_file):
        #parser = argparse.ArgumentParser(
        #    description='Generate examples for RASA from template')
        #parser.add_argument('-p', '--template-path',
        #                   default='template.json', type=str, help='Template file path. Default ./template.json')
        #parser.add_argument('-m', '--max-examples-per-line', default='100', type=int,
        #                    help='Maximum numer of examples generated by each line of templates')
        #args = parser.parse_args()

        print('Excel Sheet to JSON:\n', template_file)

        raw_intent_templates = template_file["question_number"]
        parsed_intent_templates = self.__parse_templates(raw_intent_templates)

        self.__build_examples(parsed_intent_templates, 100)

 
    def __build_examples(self, intent_templates: Dict[str, List[PhraseTemplate]], max_examples_per_line) -> List[str]:
        # reproducible randomization in future runs
        reproducible_random = random.Random(1)
        examples_count = 0

        #define the first raw
        rows_list = {
                        "question_type" : [], 
                        "question_number" : [], 
                        "question" : [], 
                        "answer" : [], 
                        "note" : []
                    }

        for intent_name, phrase_templates in intent_templates.items():
                logger.info(f"Generating examples of intent '{intent_name}' ...")
                for template in phrase_templates:
                    #output_file.write(f"<!-- {template.original_line} -->\n")
                    expanded_slot_lists = self.__expand_references_inside_slots(template)
                        
                    #logger.info(f"expanded_slot_lists: {expanded_slot_lists}")
                    cartesian_product_examples_count = reduce(
                        lambda a, b: a*b, [len(s) for s in expanded_slot_lists], 1)
                    if cartesian_product_examples_count < max_examples_per_line:
                        #if the cartesian product has less example than the maximum defined generate all of them
                        filling_words_list = list(
                            itertools.product(*expanded_slot_lists))
                    elif cartesian_product_examples_count < 1048576:  # reasonable # of prods to compute --> 2^20
                        prods = list(itertools.product(*expanded_slot_lists))
                        filling_words_list = reproducible_random.sample(
                            prods, k=max_examples_per_line)
                    else:
                        filling_words_list = set()
                        # otherwise build #max_examples_per_line example randomly
                        while len(filling_words_list) < max_examples_per_line:
                            # only unique set of words can be in filling_words_list to do not generate duplicate examples ¯\_(ツ)_/¯
                            random_words_from_slots = tuple(
                                [reproducible_random.choice(slot) for slot in expanded_slot_lists])
                            filling_words_list.add(random_words_from_slots)
                    # fill strings with slots
                    filled_template_list = []
                    for filling_words in filling_words_list:
                        filled_template_list.append(
                            template.string_to_fill.format(*filling_words))
                    # print on file
                    for filled in sorted(filled_template_list):
                        rows_list["question_type"].append(self.file_data[intent_name][0]) 
                        rows_list["question_number"].append(intent_name)
                        rows_list["question"].append(filled)
                        rows_list["answer"].append(self.file_data[intent_name][3])
                        rows_list["note"].append(self.file_data[intent_name][4])
                    logger.info(
                        f"  {len(filled_template_list)} examples of template \"{template.original_line}\"")
                    examples_count += len(filled_template_list)
        logger.info(f"Generation completed - total examples: {examples_count}")

        df = pd.DataFrame(rows_list)
        with pd.ExcelWriter(self.file_name, engine='openpyxl', mode='a') as writer:
            df.to_excel(writer, sheet_name='FAQ_generated', index=False)


    def __parse_templates(self, raw_intent_templates: Dict) -> Dict:
        parsed_templates = {}
        for intent_name, phrase_templates in raw_intent_templates.items():
            parsed_templates[intent_name] = self.__parse_phrase_templates(
                phrase_templates)
        return parsed_templates


    def __parse_phrase_templates(self, raw_line_templates: List) -> List[PhraseTemplate]:
        '''
        Parse line from file to Template class
        '''
        parserd_line_templates = []
        for line in raw_line_templates:
            pattern = r"((\[(.*?)\])|(\$[a-zA-Z_]*))"
            found = re.findall(pattern, line)
            # take the first group of match, it can be [word1|word2] or $var
            slots = [f[0] for f in found]
            # transform matches to lists
            slot_list = self.__parse_slots_to_lists(slots)
            # create the string that will formatted with the words from the references, es: "The [car|vehicle] is $color" --> "The {} is {}"
            string_to_fill = re.sub(pattern, '{}', line)
            parserd_line_templates.append(PhraseTemplate(line, string_to_fill, slot_list))
        return parserd_line_templates

 
    def __parse_slots_to_lists(self, slots: List[str]) -> List[List[str]]:
        '''
        ["[word1|word2]", "$var"] --> [["word1","word2"], "$var"] 
        '''
        slot_list = []
        for s in slots:
            slot_as_list = []
            if s[0] == '[' and s[-1] == ']':  # it is an array es: [red|blue]:
                no_brackets_reference = s[1:-1]
                slot_as_list = no_brackets_reference.split('|')
            elif s[0] == '$':  # it is a reference to entities, es $name
                slot_as_list = [s]
            else:
                logger.error(f"Slot '{s}' not recognize")
                raise ValueError(f"Slot '{s}' not recognize")
            slot_list.append(slot_as_list)
        return slot_list

    def __expand_references_inside_slots(self, template: PhraseTemplate):
        '''
        Expand slots: ['The', '$colors']->['The','Blue','Red']
        '''
        expanded_slots = [] 
        for words in template.slot_list:
            expanded_words = set([])
            for w in words:
                expanded_words.add(w)
            expanded_slots.append(list(expanded_words))
        return expanded_slots

k = knowledge_action()

k.import_k()
